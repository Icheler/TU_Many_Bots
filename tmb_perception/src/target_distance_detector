#!/usr/bin/env python3

import rospy
import rospkg
import numpy as np

from geometry_msgs.msg import Point, Pose, Quaternion
from std_msgs.msg import Bool, String, Int8
from nav_msgs.msg import Odometry

def normalize(x):
    return x / np.sqrt(np.sum(x**2))

class DistanceDetector:

    def __init__(self):
        rospack = rospkg.RosPack()

        # Initialize Publishers
        #self.pub_bearing_1 = rospy.Publisher('/tmb_perception/robot_1_target_bearing', Robot_Bearing, queue_size=10)
        self.pub_absolute_position = rospy.Publisher('/tmb_perception/blind_robot_position', Point, queue_size=10)
        self.pub_can_see = rospy.Publisher('/tmb_perception/blind_robot_seen', String, queue_size=10)

        # Initialize Subscribers
        self.sub_robot_pose = rospy.Subscriber('/robot1/odom', Odometry, self.get_pose("robot1"))
        self.sub_robot_pose = rospy.Subscriber('/robot2/odom', Odometry, self.get_pose("robot2"))
        self.blind_robot_pose = rospy.Subscriber('/robot_blind/position', Point, self.get_blind_robot)
        self.blind_robot_position = np.array([4, -3.5])


    def get_blind_robot(self, point):
        self.blind_robot_position = np.array([point.x, point.y])

    def get_pose(self, robot):
        def get_pose_func(odometry):
            pose = odometry.pose.pose.orientation
            pos = odometry.pose.pose.position
            yaw = np.arctan2(2.0*(pose.w*pose.z), pose.w*pose.w - pose.z*pose.z);
            bearing = np.array([np.cos(yaw), np.sin(yaw)])
            normalized_bearing = normalize(bearing)
            position = np.array([pos.x, pos.y])
            moved_position = position + 0.6*normalized_bearing;
            robot_to_blind = self.blind_robot_position - moved_position
            total_distance = np.linalg.norm(robot_to_blind)
            norm_robot_to_blind = normalize(robot_to_blind)
            angle_to_target = np.dot(norm_robot_to_blind, normalized_bearing)
            print('------------------------------------------')
            print("pose received for robot:", robot)
            print('distance to blind', total_distance)
            print('pose', pose)
            print('angle_to_target', angle_to_target)
            print('------------------------------------------')
            # todo add case for objects obstructing the view.
            if total_distance < 2 and total_distance > 0.6 and angle_to_target > 0.6:
                self.pub_absolute_position.publish(Point(self.blind_robot_position[0], self.blind_robot_position[1], 0))
                self.pub_can_see.publish(robot)
        return get_pose_func

    def run(self):
        while not rospy.is_shutdown():
            pass


if __name__ == "__main__":
    rospy.init_node('target_distance_detector')
    target_distance_detector = DistanceDetector()
    target_distance_detector.run()
