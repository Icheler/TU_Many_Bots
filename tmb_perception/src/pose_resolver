#!/usr/bin/env python3

import rospy
import rospkg
import numpy as np
import os


from geometry_msgs.msg import Point, Pose, Quaternion
from std_msgs.msg import Bool, String, Int8
from nav_msgs.msg import Odometry
from tmb_messages.msg import Computed_Pose
from darknet_ros_msgs.msg import BoundingBoxes
from sensor_msgs.msg import LaserScan

def quat_to_yaw(pose):
    x = pose.orientation.x
    y = pose.orientation.y
    z = pose.orientation.z
    w = pose.orientation.w
    return np.arctan2(2.0*(w*z), w*w - z*z);

class PoseResolver:
    '''
        An interface class which pipes robot position from a variety of sources
        and publishes resolved results.
    '''
    def __init__(self):
        rospack = rospkg.RosPack()

        # Initialize Publishers
        self.pub_robot_1 = rospy.Publisher('/robot1/tmb_computed_pose', Computed_Pose, queue_size=10)
        self.pub_robot_2 = rospy.Publisher('/robot2/tmb_computed_pose', Computed_Pose, queue_size=10)
        self.pub_robot_blind = rospy.Publisher('/robot_blind/tmb_computed_pose', Computed_Pose, queue_size=10)

        # Initialize Subscribers
        self.sub_robot_1_pose = rospy.Subscriber('/robot1/pose', Pose, self.get_pose('robot1'))
        self.sub_robot_2_pose = rospy.Subscriber('/robot2/pose', Pose, self.get_pose('robot2'))
        self.sub_robot_blind_pose = rospy.Subscriber('/robot_blind/pose', Pose, self.get_pose('robot_blind'))


    def get_pose(self, robot_name):
        def pos_func(pose):
            computed = Computed_Pose()
            computed.x = pose.position.x
            computed.y = pose.position.y
            computed.yaw = quat_to_yaw(pose)
            computed.quaternion_x = pose.orientation.x
            computed.quaternion_y = pose.orientation.y
            computed.quaternion_z = pose.orientation.z
            computed.quaternion_w = pose.orientation.w
            if (robot_name == 'robot1'):
                self.pub_robot_1.publish(computed)
            elif (robot_name =='robot2'):
                self.pub_robot_2.publish(computed)
            else:
                self.pub_robot_blind.publish(computed)
        return pos_func



    def run(self):
        while not rospy.is_shutdown():
            pass

if __name__ == "__main__":
    rospy.init_node('pose_resolver')
    pose_resolver = PoseResolver()
    pose_resolver.run()
